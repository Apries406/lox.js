/* Generated By generateAST.cjs */

import { Token } from './Token';

export interface Visitor<T> {
	visitAssignExpr(expr: Assign): T;
	visitBinaryExpr(expr: Binary): T;
	visitCallExpr(expr: Call): T;
	visitCommaExpr(expr: Comma): T;
	visitConditionalExpr(expr: Conditional): T;
	visitGetExpr(expr: Get): T;
	visitGroupingExpr(expr: Grouping): T;
	visitLiteralExpr(expr: Literal): T;
	visitLogicalExpr(expr: Logical): T;
	visitSetExpr(expr: Set): T;
	visitSuperExpr(expr: Super): T;
	visitThisExpr(expr: This): T;
	visitUnaryExpr(expr: Unary): T;
	visitVariableExpr(expr: Variable): T;
}
export abstract class Expr {
	abstract accept<T>(visitor: Visitor<T>): T;
}

// 赋值表达式 Statement and State
export class Assign extends Expr {
	name: Token;
	value: Expr;

	constructor(name: Token, value: Expr) {
		super();
		this.name = name;
		this.value = value;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitAssignExpr(this);
	}
}

// 二元表达式 Representing Code
export class Binary extends Expr {
	left: Expr;
	operator: Token;
	right: Expr;

	constructor(left: Expr, operator: Token, right: Expr) {
		super();
		this.left = left;
		this.operator = operator;
		this.right = right;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitBinaryExpr(this);
	}
}

// 调用表达式 Functions
export class Call extends Expr {
	callee: Expr;
	paren: Token;
	args: Array<Expr>;

	constructor(callee: Expr, paren: Token, args: Array<Expr>) {
		super();
		this.callee = callee;
		this.paren = paren;
		this.args = args;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitCallExpr(this);
	}
}

// 逗号分隔表达式 Representing Code
export class Comma extends Expr {
	left: Expr;
	operator: Token;
	right: Expr;

	constructor(left: Expr, operator: Token, right: Expr) {
		super();
		this.left = left;
		this.operator = operator;
		this.right = right;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitCommaExpr(this);
	}
}

// 条件语句 Statement and State
export class Conditional extends Expr {
	condition: Expr;
	thenBranch: Expr;
	elseBranch: Expr;

	constructor(condition: Expr, thenBranch: Expr, elseBranch: Expr) {
		super();
		this.condition = condition;
		this.thenBranch = thenBranch;
		this.elseBranch = elseBranch;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitConditionalExpr(this);
	}
}

// 获取表达式 Classes
export class Get extends Expr {
	obj: Expr;
	name: Token;

	constructor(obj: Expr, name: Token) {
		super();
		this.obj = obj;
		this.name = name;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitGetExpr(this);
	}
}

// 分组表达式(括号) Representing Code
export class Grouping extends Expr {
	expression: Expr;

	constructor(expression: Expr) {
		super();
		this.expression = expression;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitGroupingExpr(this);
	}
}

// 文本值表达式 Representing Code
export class Literal extends Expr {
	value: any;

	constructor(value: any) {
		super();
		this.value = value;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitLiteralExpr(this);
	}
}

// 逻辑表达式(and & or) Control Flow
export class Logical extends Expr {
	left: Expr;
	operator: Token;
	right: Expr;

	constructor(left: Expr, operator: Token, right: Expr) {
		super();
		this.left = left;
		this.operator = operator;
		this.right = right;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitLogicalExpr(this);
	}
}

// 设置表达式(set) Classes
export class Set extends Expr {
	obj: Expr;
	name: Token;
	value: Expr;

	constructor(obj: Expr, name: Token, value: Expr) {
		super();
		this.obj = obj;
		this.name = name;
		this.value = value;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitSetExpr(this);
	}
}

// super表达式(super) Classes
export class Super extends Expr {
	keyword: Token;
	method: Token;

	constructor(keyword: Token, method: Token) {
		super();
		this.keyword = keyword;
		this.method = method;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitSuperExpr(this);
	}
}

// this表达式 Classes
export class This extends Expr {
	keyword: Token;

	constructor(keyword: Token) {
		super();
		this.keyword = keyword;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitThisExpr(this);
	}
}

// 一元表达式 Representing Code
export class Unary extends Expr {
	operator: Token;
	right: Expr;

	constructor(operator: Token, right: Expr) {
		super();
		this.operator = operator;
		this.right = right;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitUnaryExpr(this);
	}
}

// 变量表达式
export class Variable extends Expr {
	name: Token;

	constructor(name: Token) {
		super();
		this.name = name;
	}

	accept<T>(visitor: Visitor<T>): T {
		return visitor.visitVariableExpr(this);
	}
}
